{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Network Decision Boundary</title>
    <link rel="stylesheet" href="{% static 'graph_styles.css' %}">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
</head>
<body>
    <div class="status" id="connectionStatus">
        <div class="loading-spinner"></div>
        <div class="status-title">Connection Status</div>
        <div>Connecting to neural network...</div>
    </div>

    <div class="container">
        <div class="panel">
            <div class="panel-title">Neural Network Decision Boundary</div>
            
            <div class="epoch-info">
                <div class="metrics-group">
                    <div class="metric">
                        <span>Epoch:</span>
                        <span class="epoch-value" id="currentEpoch">-</span>
                    </div>
                    <div class="metric">
                        <span>Accuracy:</span>
                        <span class="accuracy-value" id="accuracyValue">-</span>
                    </div>
                </div>
                
                <div class="graph-action-buttons">
                    <button type="button" class="graph-btn graph-train-btn" id="graphTrainBtn">
                        <span class="graph-btn-icon">üöÄ</span>
                        Train
                    </button>
                    <button type="button" class="graph-btn graph-home-btn" id="graphHomeBtn">
                        <span class="graph-btn-icon">üè†</span>
                        Home
                    </button>
                </div>
            </div>
            
            <svg id="plot-svg"></svg>
            
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color class-0"></div>
                    <span>Class 0 (Red)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color class-1"></div>
                    <span>Class 1 (Teal)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: white; height: 2px; width: 20px; border-radius: 1px;"></div>
                    <span>Decision Boundary</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        class SimpleNeuralViz {
            constructor() {
                this.data = { x: [], y: [], labels: [], predicted: [] };
                this.width = 800;
                this.height = 600;
                this.margin = { top: 20, right: 20, bottom: 40, left: 50 };
                this.plotWidth = this.width - this.margin.left - this.margin.right;
                this.plotHeight = this.height - this.margin.top - this.margin.bottom;
                
                this.xExtent = [-3, 3];
                this.yExtent = [-3, 3];
                this.currentEpoch = 0;
                this.accuracy = 0;
                
                this.svg = d3.select('#plot-svg');
                this.ws = null;
                
                this.init();
                this.initWebSocket();
                this.initButtons();
            }

            init() {
                this.setupScales();
                this.setupSVG();
            }

            setupScales() {
                this.xScale = d3.scaleLinear().domain(this.xExtent).range([0, this.plotWidth]);
                this.yScale = d3.scaleLinear().domain(this.yExtent).range([this.plotHeight, 0]);
            }

            setupSVG() {
                this.svg.attr('width', this.width).attr('height', this.height);
                
                this.plotGroup = this.svg.append('g')
                    .attr('class', 'plot-group')
                    .attr('transform', `translate(${this.margin.left}, ${this.margin.top})`);
            }

            initWebSocket() {
                const statusEl = document.getElementById('connectionStatus');
                
                try {
                    const loc = window.location;
                    let wsStart = loc.protocol === "https:" ? "wss://" : "ws://";
                    let endpoint = wsStart + loc.host + "/ws/training/graph";
                    this.ws = new WebSocket(endpoint);
                    
                    this.ws.onopen = () => {
                        statusEl.innerHTML = '<div class="status-title">Connected</div><div>Receiving neural network data...</div>';
                        statusEl.className = 'status connected';
                    };

                    this.ws.onmessage = (event) => {
                        const data = JSON.parse(event.data);
                        if (data.type === "training_update") {
                            this.updateData(data.data);
                        }
                    };

                    this.ws.onclose = () => {
                        statusEl.innerHTML = '<div class="status-title">Disconnected</div><div>Connection lost</div>';
                        statusEl.className = 'status error';
                    };
                    
                } catch (error) {
                    statusEl.innerHTML = '<div class="status-title">Connection Error</div>';
                    statusEl.className = 'status error';
                }
            }

            initButtons() {
                document.getElementById("graphTrainBtn").addEventListener("click", () => {
                    fetch("/train/")
                        .then(response => response.json())
                        .then(data => {
                            console.log("Training started");
                        })
                        .catch(err => {
                            alert("Training Error: " + err);
                        });
                });

                document.getElementById("graphHomeBtn").addEventListener("click", () => {
                    window.location.href = "/NN/";
                });
            }

            updateData(data) {
                // Flatten nested arrays [[],[],[]] to []
                this.data = {
                    x: data.x.flat(),
                    y: data.y.flat(),
                    labels: data.labels.flat(),
                    predicted: data.predicted.flat()
                };
                
                this.currentEpoch = data.epoch || 0;
                this.updateMetrics();
                this.render();
            }

            updateMetrics() {
                document.getElementById('currentEpoch').textContent = this.currentEpoch;
                
                let correct = 0;
                for (let i = 0; i < this.data.labels.length; i++) {
                    if (Math.round(this.data.predicted[i]) === this.data.labels[i]) {
                        correct++;
                    }
                }
                
                this.accuracy = this.data.labels.length > 0 ? 
                    (correct / this.data.labels.length * 100).toFixed(1) : 0;
                document.getElementById('accuracyValue').textContent = this.accuracy + '%';
            }

            render() {
                this.plotGroup.selectAll('*').remove();
                
                this.drawAxes();
                this.drawDecisionBoundary();
                this.drawDataPoints();
            }

            drawAxes() {
                // Draw grid lines first
                const xTicks = this.xScale.ticks(6);
                const yTicks = this.yScale.ticks(6);

                this.plotGroup.selectAll('.grid-x')
                    .data(xTicks)
                    .join('line')
                    .attr('class', 'grid-x grid-line')
                    .attr('x1', d => this.xScale(d))
                    .attr('x2', d => this.xScale(d))
                    .attr('y1', 0)
                    .attr('y2', this.plotHeight);

                this.plotGroup.selectAll('.grid-y')
                    .data(yTicks)
                    .join('line')
                    .attr('class', 'grid-y grid-line')
                    .attr('x1', 0)
                    .attr('x2', this.plotWidth)
                    .attr('y1', d => this.yScale(d))
                    .attr('y2', d => this.yScale(d));

                // Draw axes
                const xAxis = d3.axisBottom(this.xScale).ticks(5).tickFormat(d3.format('.1f'));
                this.plotGroup.append('g')
                    .attr('class', 'x-axis axis')
                    .attr('transform', `translate(0, ${this.plotHeight})`)
                    .call(xAxis);

                const yAxis = d3.axisLeft(this.yScale).ticks(5).tickFormat(d3.format('.1f'));
                this.plotGroup.append('g')
                    .attr('class', 'y-axis axis')
                    .call(yAxis);
            }

            drawDecisionBoundary() {
                const resolution = 40;
                const xStep = (this.xExtent[1] - this.xExtent[0]) / resolution;
                const yStep = (this.yExtent[1] - this.yExtent[0]) / resolution;
                const cellWidth = this.plotWidth / resolution;
                const cellHeight = this.plotHeight / resolution;
                
                // Draw background contours
                for (let i = 0; i < resolution; i++) {
                    for (let j = 0; j < resolution; j++) {
                        const x = this.xExtent[0] + i * xStep;
                        const y = this.yExtent[0] + j * yStep;
                        const prediction = this.predict(x, y);
                        
                        this.plotGroup.append('rect')
                            .attr('class', 'contour-cell')
                            .attr('x', this.xScale(x) - cellWidth/2)
                            .attr('y', this.yScale(y) - cellHeight/2)
                            .attr('width', cellWidth)
                            .attr('height', cellHeight)
                            .attr('fill', prediction > 0.5 ? '#4ecdc4' : '#ff6b6b')
                            .attr('opacity', 0.12);
                    }
                }
                
                // Draw boundary lines
                const boundaryPoints = [];
                for (let i = 0; i < resolution - 1; i++) {
                    for (let j = 0; j < resolution - 1; j++) {
                        const x1 = this.xExtent[0] + i * xStep;
                        const y1 = this.yExtent[0] + j * yStep;
                        const x2 = x1 + xStep;
                        const y2 = y1 + yStep;
                        
                        const predictions = [
                            this.predict(x1, y1),
                            this.predict(x2, y1),
                            this.predict(x2, y2),
                            this.predict(x1, y2)
                        ];
                        
                        const hasClass0 = predictions.some(p => p <= 0.5);
                        const hasClass1 = predictions.some(p => p > 0.5);
                        
                        if (hasClass0 && hasClass1) {
                            boundaryPoints.push([
                                this.xScale(x1 + xStep/2), 
                                this.yScale(y1 + yStep/2)
                            ]);
                        }
                    }
                }
                
                // Draw boundary points as white circles
                this.plotGroup.selectAll('.boundary-point')
                    .data(boundaryPoints)
                    .join('circle')
                    .attr('class', 'boundary-point')
                    .attr('cx', d => d[0])
                    .attr('cy', d => d[1])
                    .attr('r', 1.5)
                    .attr('fill', '#ffffff')
                    .attr('opacity', 0.95)
                    .style('filter', 'drop-shadow(0px 0px 1px rgba(0,0,0,0.3))');
            }

            predict(x, y) {
                if (this.data.x.length === 0) return 0.5;
                
                // Simple nearest neighbor prediction
                let minDist = Infinity;
                let nearestPrediction = 0.5;
                
                for (let i = 0; i < this.data.x.length; i++) {
                    const dist = Math.pow(this.data.x[i] - x, 2) + Math.pow(this.data.y[i] - y, 2);
                    if (dist < minDist) {
                        minDist = dist;
                        nearestPrediction = this.data.predicted[i];
                    }
                }
                
                return nearestPrediction;
            }

            drawDataPoints() {
                const points = this.data.x.map((x, i) => ({
                    x: this.xScale(x),
                    y: this.yScale(this.data.y[i]),
                    label: this.data.labels[i],
                    predicted: this.data.predicted[i],
                    isCorrect: Math.round(this.data.predicted[i]) === this.data.labels[i]
                }));

                this.plotGroup.selectAll('.data-point')
                    .data(points)
                    .join('circle')
                    .attr('class', d => `data-point class-${d.label}`)
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y)
                    .attr('r', 4)
                    .style('stroke', d => d.isCorrect ? 'rgba(255, 255, 255, 0.9)' : '#ff0000')
                    .style('stroke-width', d => d.isCorrect ? 2 : 2.5);
            }
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            window.neuralViz = new SimpleNeuralViz();
        });
    </script>
</body>
</html>