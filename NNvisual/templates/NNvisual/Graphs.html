{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Network Decision Boundary</title>
    <link rel="stylesheet" href="{% static 'graph_styles.css' %}">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
</head>
<body>
    <div class="status" id="connectionStatus">
        <div class="loading-spinner"></div>
        <div class="status-title">Connection Status</div>
        <div>Connecting to neural network...</div>
    </div>

    <div class="container">
        <div class="panel">
            <div class="panel-title">Neural Network Decision Boundary</div>
            
            <div class="controls">
                <div class="control-group">
                    <input type="hidden" id="resolution" value="40" min="20" max="100">
                </div>
                <div class="control-group">
                    <input type="hidden" id="showContours" checked>
                </div>
                <div class="control-group">
                    <input type="hidden" id="autoUpdate" checked>
                </div>
            </div>
            
            <div class="epoch-info">
                <div class="metrics-group">
                    <div class="metric">
                        <span>Epoch:</span>
                        <span class="epoch-value" id="currentEpoch">-</span>
                    </div>
                    <div class="metric">
                        <span>Accuracy:</span>
                        <span class="accuracy-value" id="accuracyValue">-</span>
                    </div>
                    <div class="metric fps-counter">
                        <span>FPS:</span>
                        <span id="fpsValue">-</span>
                    </div>
                </div>
                
                <div class="graph-action-buttons">
                    <button type="button" class="graph-btn graph-train-btn" id="graphTrainBtn">
                        <span class="graph-btn-icon">üöÄ</span>
                        Train
                    </button>
                    <button type="button" class="graph-btn graph-home-btn" id="graphHomeBtn">
                        <span class="graph-btn-icon">üè†</span>
                        Home
                    </button>
                </div>
            </div>
            
            <svg id="plot-svg"></svg>
            
            <div class="performance-stats">
                Points: <span id="pointCount">0</span> | 
                Render: <span id="renderTime">0</span>ms |
                Updates: <span id="updateCount">0</span>
            </div>
            
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color class-0"></div>
                    <span>Class 0 (Red)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color class-1"></div>
                    <span>Class 1 (Teal)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: white; height: 2px; width: 20px; border-radius: 1px;"></div>
                    <span>Decision Boundary</span>
                </div>
                <div class="legend-item">
                    <div style="width: 14px; height: 14px; border: 2px solid #ff0000; border-radius: 50%;"></div>
                    <span>Misclassified</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        class OptimizedNeuralViz {
            constructor() {
                this.data = { x: [], y: [], labels: [], predicted: [] };
                
                // Performance settings
                this.maxRenderPoints = 3000;
                this.updateThrottle = 60;
                this.lastUpdateTime = 0;
                this.frameCount = 0;
                this.fps = 0;
                this.updateCount = 0;
                
                // Caching
                this.boundaryCache = new Map();
                this.predictionCache = new Map();
                this.lastResolution = null;
                this.lastDataHash = null;
                
                // Canvas dimensions
                this.width = 0;
                this.height = 0;
                this.margin = { top: 20, right: 20, bottom: 40, left: 50 };
                
                // Data extents
                this.xExtent = [-3, 3];
                this.yExtent = [-3, 3];
                
                // State
                this.currentEpoch = 0;
                this.accuracy = 0;
                this.hasData = false;
                this.isRendering = false;
                
                // D3 selections
                this.svg = d3.select('#plot-svg');
                this.plotGroup = null;
                
                // WebSocket
                this.ws = null;
                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = 5;
                
                // Animation
                this.animationFrame = null;
                this.renderScheduled = false;
                
                this.init();
                this.initWebSocket();
                this.startFPSCounter();
                this.initializeGraphButtons();
            }

            init() {
                this.setupEventListeners();
                this.updateDimensions();
                this.setupScales();
                this.setupSVG();
            }

            setupEventListeners() {
                let resizeTimeout;
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => this.handleResize(), 200);
                });
            }

            startFPSCounter() {
                let lastTime = performance.now();
                let frameCount = 0;
                
                const updateFPS = () => {
                    const now = performance.now();
                    frameCount++;
                    
                    if (now - lastTime >= 1000) {
                        this.fps = Math.round(frameCount * 1000 / (now - lastTime));
                        document.getElementById('fpsValue').textContent = this.fps;
                        frameCount = 0;
                        lastTime = now;
                    }
                    
                    requestAnimationFrame(updateFPS);
                };
                
                updateFPS();
            }

            initWebSocket() {
                const statusEl = document.getElementById('connectionStatus');
                
                try {
                    const loc = window.location;
                    let wsStart = loc.protocol === "https:" ? "wss://" : "ws://";
                    let endpoint = wsStart + loc.host + "/ws/training/graph";
                    this.ws = new WebSocket(endpoint);
                    
                    this.ws.onopen = () => {
                        this.reconnectAttempts = 0;
                        statusEl.innerHTML = '<div class="status-title">Connected</div><div>Receiving neural network data...</div>';
                        statusEl.className = 'status connected';
                    };

                    this.ws.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            if (data.type === "training_update" && document.getElementById('autoUpdate').checked) {
                                this.processData(data.data);
                            }
                        } catch (error) {
                            console.error('Error parsing WebSocket data:', error);
                        }
                    };

                    this.ws.onclose = () => {
                        if (this.reconnectAttempts < this.maxReconnectAttempts) {
                            statusEl.innerHTML = `<div class="loading-spinner"></div><div class="status-title">Reconnecting</div><div>Attempt ${this.reconnectAttempts + 1}/${this.maxReconnectAttempts}</div>`;
                            statusEl.className = 'status waiting';
                            
                            setTimeout(() => {
                                this.reconnectAttempts++;
                                this.initWebSocket();
                            }, 2000 * Math.pow(2, this.reconnectAttempts));
                        } else {
                            statusEl.innerHTML = '<div class="status-title">Connection Failed</div><div>Unable to connect to neural network</div>';
                            statusEl.className = 'status error';
                        }
                    };

                    this.ws.onerror = (error) => console.error('WebSocket error:', error);
                    
                } catch (error) {
                    statusEl.innerHTML = '<div class="status-title">Connection Error</div><div>Failed to establish connection</div>';
                    statusEl.className = 'status error';
                }
            }

            initializeGraphButtons() {
                const trainBtn = document.getElementById("graphTrainBtn");
                if (trainBtn) {
                    trainBtn.addEventListener("click", () => {
                        trainBtn.classList.add('loading');
                        trainBtn.innerHTML = '<span class="graph-btn-spinner"></span>Training...';
                        trainBtn.disabled = true;
                        
                        fetch("/train/")
                            .then(response => response.json())
                            .then(data => {
                                trainBtn.classList.remove('loading');
                                trainBtn.classList.add('success');
                                trainBtn.innerHTML = '<span class="graph-btn-icon">‚úì</span>Started';
                                trainBtn.disabled = false;
                                
                                setTimeout(() => {
                                    trainBtn.classList.remove('success');
                                    trainBtn.innerHTML = '<span class="graph-btn-icon">üöÄ</span>Train';
                                }, 2000);
                            })
                            .catch(err => {
                                trainBtn.classList.remove('loading');
                                trainBtn.classList.add('error');
                                trainBtn.innerHTML = '<span class="graph-btn-icon">‚úï</span>Error';
                                trainBtn.disabled = false;
                                
                                setTimeout(() => {
                                    trainBtn.classList.remove('error');
                                    trainBtn.innerHTML = '<span class="graph-btn-icon">üöÄ</span>Train';
                                }, 3000);
                                
                                alert("Training Error: " + err);
                            });
                    });
                }

                const homeBtn = document.getElementById("graphHomeBtn");
                if (homeBtn) {
                    homeBtn.addEventListener("click", () => {
                        homeBtn.classList.add('loading');
                        homeBtn.innerHTML = '<span class="graph-btn-spinner"></span>Loading...';
                        homeBtn.disabled = true;
                        
                        setTimeout(() => {
                            window.location.href = "/NN/";
                            homeBtn.classList.remove('loading');
                            homeBtn.innerHTML = '<span class="graph-btn-icon">üè†</span>Home';
                            homeBtn.disabled = false;
                        }, 300);
                    });
                }
            }

            processData(data) {
                const now = performance.now();
                if (now - this.lastUpdateTime < this.updateThrottle) return;
                this.lastUpdateTime = now;

                if (!this.validateData(data)) return;

                const sampleData = this.sampleDataForPerformance(data);
                
                this.data = {
                    x: sampleData.x,
                    y: sampleData.y,
                    labels: sampleData.labels,
                    predicted: sampleData.predicted
                };

                this.updateMetrics(data);
                this.updateExtents();
                this.setupScales();
                
                // Always invalidate cache when new data arrives
                const dataHash = this.hashData(this.data);
                if (dataHash !== this.lastDataHash) {
                    this.invalidateCache();
                    this.lastDataHash = dataHash;
                    console.log('Data changed, cache invalidated'); // Debug log
                }
                
                this.hasData = true;
                this.scheduleRender();
                this.updateStatus();
                
                this.updateCount++;
                document.getElementById('updateCount').textContent = this.updateCount;
            }

            hashData(data) {
                // Include predicted values in hash to detect model changes
                const predictedSample = data.predicted.slice(0, 50).map(p => Math.round(p * 100)).join('');
                return data.x.length + '_' + data.labels.join('').slice(0, 20) + '_' + predictedSample;
            }

            validateData(data) {
                return data.x && data.y && data.labels && data.predicted && 
                       data.x.length === data.y.length && 
                       data.y.length === data.labels.length && 
                       data.labels.length === data.predicted.length;
            }

            sampleDataForPerformance(data) {
                if (data.x.length <= this.maxRenderPoints) return data;

                // Stratified sampling
                const class0Indices = [];
                const class1Indices = [];
                
                data.labels.forEach((label, i) => {
                    if (label === 0) class0Indices.push(i);
                    else class1Indices.push(i);
                });
                
                const sampleSize = Math.min(this.maxRenderPoints, data.x.length);
                const class0Sample = Math.floor(sampleSize * class0Indices.length / data.labels.length);
                const class1Sample = sampleSize - class0Sample;
                
                const shuffled0 = class0Indices.sort(() => 0.5 - Math.random());
                const shuffled1 = class1Indices.sort(() => 0.5 - Math.random());
                
                const indices = [...shuffled0.slice(0, class0Sample), ...shuffled1.slice(0, class1Sample)];
                
                return {
                    x: indices.map(i => data.x[i]),
                    y: indices.map(i => data.y[i]),
                    labels: indices.map(i => data.labels[i]),
                    predicted: indices.map(i => data.predicted[i])
                };
            }

            updateMetrics(data) {
                if (data.epoch !== undefined) {
                    this.currentEpoch = data.epoch;
                    document.getElementById('currentEpoch').textContent = this.currentEpoch;
                }

                let correct = 0;
                const total = Math.min(data.labels.length, data.predicted.length);
                for (let i = 0; i < total; i++) {
                    if (Math.round(data.predicted[i]) === data.labels[i]) correct++;
                }
                
                this.accuracy = total > 0 ? (correct / total * 100).toFixed(1) : 0;
                document.getElementById('accuracyValue').textContent = this.accuracy + '%';
                document.getElementById('pointCount').textContent = data.x.length;
            }

            updateExtents() {
                if (this.data.x.length === 0) return;
                
                const xExtent = d3.extent(this.data.x);
                const yExtent = d3.extent(this.data.y);
                
                const xPadding = Math.max((xExtent[1] - xExtent[0]) * 0.1, 0.5);
                const yPadding = Math.max((yExtent[1] - yExtent[0]) * 0.1, 0.5);
                
                this.xExtent = [xExtent[0] - xPadding, xExtent[1] + xPadding];
                this.yExtent = [yExtent[0] - yPadding, yExtent[1] + yPadding];
            }

            updateDimensions() {
                const container = document.querySelector('.panel');
                const rect = container.getBoundingClientRect();
                
                this.width = rect.width - 48;
                this.height = rect.height - 200;
                
                this.plotWidth = this.width - this.margin.left - this.margin.right;
                this.plotHeight = this.height - this.margin.top - this.margin.bottom;
            }

            setupScales() {
                this.xScale = d3.scaleLinear().domain(this.xExtent).range([0, this.plotWidth]);
                this.yScale = d3.scaleLinear().domain(this.yExtent).range([this.plotHeight, 0]);
            }

            setupSVG() {
                this.svg.attr('width', this.width).attr('height', this.height);
                this.svg.selectAll('.plot-group').remove();
                
                this.plotGroup = this.svg.append('g')
                    .attr('class', 'plot-group')
                    .attr('transform', `translate(${this.margin.left}, ${this.margin.top})`);

                this.plotGroup.append('defs').append('clipPath').attr('id', 'plot-area')
                    .append('rect').attr('width', this.plotWidth).attr('height', this.plotHeight);
            }

            scheduleRender() {
                if (this.renderScheduled || this.isRendering) return;
                
                this.renderScheduled = true;
                this.animationFrame = requestAnimationFrame(() => {
                    this.renderScheduled = false;
                    this.render();
                });
            }

            render() {
                if (!this.hasData || this.isRendering) return;
                
                const startTime = performance.now();
                this.isRendering = true;

                try {
                    this.renderGrid();
                    this.renderAxes();
                    this.renderDecisionBoundary();
                    this.renderDataPoints();
                    
                    const renderTime = Math.round(performance.now() - startTime);
                    document.getElementById('renderTime').textContent = renderTime;
                    
                } catch (error) {
                    console.error('Render error:', error);
                } finally {
                    this.isRendering = false;
                }
            }

            renderGrid() {
                const xTicks = this.xScale.ticks(6);
                const yTicks = this.yScale.ticks(6);

                this.plotGroup.selectAll('.grid-line').remove();

                this.plotGroup.selectAll('.grid-x')
                    .data(xTicks)
                    .join('line')
                    .attr('class', 'grid-x grid-line')
                    .attr('x1', d => this.xScale(d))
                    .attr('x2', d => this.xScale(d))
                    .attr('y1', 0)
                    .attr('y2', this.plotHeight);

                this.plotGroup.selectAll('.grid-y')
                    .data(yTicks)
                    .join('line')
                    .attr('class', 'grid-y grid-line')
                    .attr('x1', 0)
                    .attr('x2', this.plotWidth)
                    .attr('y1', d => this.yScale(d))
                    .attr('y2', d => this.yScale(d));
            }

            renderAxes() {
                this.plotGroup.selectAll('.x-axis').remove();
                this.plotGroup.selectAll('.y-axis').remove();
                
                const xAxis = d3.axisBottom(this.xScale).ticks(5).tickFormat(d3.format('.1f'));
                this.plotGroup.append('g')
                    .attr('class', 'x-axis axis')
                    .attr('transform', `translate(0, ${this.plotHeight})`)
                    .call(xAxis);

                const yAxis = d3.axisLeft(this.yScale).ticks(5).tickFormat(d3.format('.1f'));
                this.plotGroup.append('g')
                    .attr('class', 'y-axis axis')
                    .call(yAxis);
            }

            renderDecisionBoundary() {
                const resolution = parseInt(document.getElementById('resolution').value);
                // Force cache invalidation on every epoch change
                const cacheKey = `${resolution}_${this.currentEpoch}_${this.lastDataHash}`;
                
                if (this.boundaryCache.has(cacheKey)) {
                    this.drawCachedBoundary(cacheKey);
                    return;
                }

                // Clear old cache entries to prevent memory bloat
                if (this.boundaryCache.size > 5) {
                    this.boundaryCache.clear();
                }

                const gridData = this.generateGridWithContours(resolution);
                this.boundaryCache.set(cacheKey, gridData);
                this.drawBoundaryFromGrid(gridData, resolution);
            }

            generateGridWithContours(resolution) {
                const xStep = (this.xExtent[1] - this.xExtent[0]) / resolution;
                const yStep = (this.yExtent[1] - this.yExtent[0]) / resolution;
                const boundaryPoints = [];
                const contourCells = [];
                const cellWidth = this.plotWidth / resolution;
                const cellHeight = this.plotHeight / resolution;

                // Generate grid with background contours
                for (let i = 0; i < resolution; i++) {
                    for (let j = 0; j < resolution; j++) {
                        const x = this.xExtent[0] + i * xStep;
                        const y = this.yExtent[0] + j * yStep;
                        const prediction = this.fastPredict(x, y);
                        
                        // Add background cell for visual richness
                        contourCells.push({
                            x: this.xScale(x) - cellWidth/2,
                            y: this.yScale(y) - cellHeight/2,
                            width: cellWidth,
                            height: cellHeight,
                            prediction: prediction
                        });
                        
                        // Check for boundary (compare with neighbors)
                        if (i < resolution - 1 && j < resolution - 1) {
                            const rightX = x + xStep;
                            const downY = y + yStep;
                            const predictions = [
                                prediction,
                                this.fastPredict(rightX, y),
                                this.fastPredict(rightX, downY),
                                this.fastPredict(x, downY)
                            ];
                            
                            const hasClass0 = predictions.some(p => p <= 0.5);
                            const hasClass1 = predictions.some(p => p > 0.5);
                            
                            if (hasClass0 && hasClass1) {
                                boundaryPoints.push([
                                    this.xScale(x + xStep/2), 
                                    this.yScale(y + yStep/2)
                                ]);
                            }
                        }
                    }
                }

                return { boundaryPoints, contourCells };
            }

            drawBoundaryFromGrid(gridData, resolution) {
                this.plotGroup.selectAll('.contour-cell').remove();
                this.plotGroup.selectAll('.boundary-point').remove();

                const { boundaryPoints, contourCells } = gridData;
                
                // Draw background contour cells for visual richness
                this.plotGroup.selectAll('.contour-cell')
                    .data(contourCells)
                    .join('rect')
                    .attr('class', 'contour-cell')
                    .attr('x', d => d.x)
                    .attr('y', d => d.y)
                    .attr('width', d => d.width)
                    .attr('height', d => d.height)
                    .attr('fill', d => d.prediction > 0.5 ? '#4ecdc4' : '#ff6b6b')
                    .attr('opacity', 0.12);
                
                // Draw boundary points with better visibility
                if (boundaryPoints.length > 0) {
                    this.plotGroup.selectAll('.boundary-point')
                        .data(boundaryPoints)
                        .join('circle')
                        .attr('class', 'boundary-point')
                        .attr('cx', d => d[0])
                        .attr('cy', d => d[1])
                        .attr('r', 1.5)
                        .attr('fill', '#ffffff')
                        .attr('opacity', 0.95)
                        .style('filter', 'drop-shadow(0px 0px 1px rgba(0,0,0,0.3))');
                }
            }

            drawCachedBoundary(cacheKey) {
                const cachedData = this.boundaryCache.get(cacheKey);
                if (cachedData) {
                    this.drawBoundaryFromGrid(cachedData, this.lastResolution);
                }
            }

            fastPredict(x, y) {
                if (this.data.x.length === 0) return 0.5;
                
                const cacheKey = `${x.toFixed(2)}_${y.toFixed(2)}`;
                if (this.predictionCache.has(cacheKey)) {
                    return this.predictionCache.get(cacheKey);
                }
                
                // k-nearest neighbors with distance weighting
                const k = Math.min(3, this.data.x.length);
                const neighbors = [];
                
                for (let i = 0; i < this.data.x.length; i++) {
                    const dx = this.data.x[i] - x;
                    const dy = this.data.y[i] - y;
                    const dist = dx * dx + dy * dy;
                    neighbors.push({ dist, prediction: this.data.predicted[i] });
                }
                
                neighbors.sort((a, b) => a.dist - b.dist);
                
                let weightedSum = 0;
                let weightSum = 0;
                
                for (let i = 0; i < k; i++) {
                    const weight = 1 / (neighbors[i].dist + 1e-6);
                    weightedSum += neighbors[i].prediction * weight;
                    weightSum += weight;
                }
                
                const result = weightSum > 0 ? weightedSum / weightSum : 0.5;
                
                // Cache result
                if (this.predictionCache.size > 1000) {
                    this.predictionCache.clear();
                }
                this.predictionCache.set(cacheKey, result);
                
                return result;
            }

            renderDataPoints() {
                const points = this.data.x.map((x, i) => ({
                    x: this.xScale(x),
                    y: this.yScale(this.data.y[i]),
                    label: this.data.labels[i],
                    predicted: this.data.predicted[i],
                    isCorrect: Math.round(this.data.predicted[i]) === this.data.labels[i]
                }));

                this.plotGroup.selectAll('.data-point')
                    .data(points, (d, i) => i)
                    .join(
                        enter => enter.append('circle')
                            .attr('class', d => `data-point class-${d.label}`)
                            .attr('cx', d => d.x)
                            .attr('cy', d => d.y)
                            .attr('r', 4)
                            .style('stroke-width', d => d.isCorrect ? 1.5 : 2.5)
                            .style('stroke', d => d.isCorrect ? 'rgba(255, 255, 255, 0.9)' : '#ff0000')
                            .attr('clip-path', 'url(#plot-area)')
                            .style('filter', 'drop-shadow(0px 1px 2px rgba(0,0,0,0.2))')
                            .on('mouseover', function(event, d) {
                                d3.select(this)
                                    .transition().duration(150)
                                    .attr('r', 5.5)
                                    .style('stroke-width', d.isCorrect ? 2 : 3);
                            })
                            .on('mouseout', function(event, d) {
                                d3.select(this)
                                    .transition().duration(150)
                                    .attr('r', 4)
                                    .style('stroke-width', d.isCorrect ? 1.5 : 2.5);
                            }),
                        
                        update => update
                            .attr('cx', d => d.x)
                            .attr('cy', d => d.y)
                            .style('stroke-width', d => d.isCorrect ? 1.5 : 2.5)
                            .style('stroke', d => d.isCorrect ? 'rgba(255, 255, 255, 0.9)' : '#ff0000')
                    );
            }

            invalidateCache() {
                this.boundaryCache.clear();
                this.predictionCache.clear();
            }

            updateStatus() {
                const statusEl = document.getElementById('connectionStatus');
                statusEl.innerHTML = `
                    <div class="status-title">Live Training</div>
                    <div>Points: ${this.data.x.length} | Epoch: ${this.currentEpoch} | Accuracy: ${this.accuracy}%</div>
                `;
                statusEl.className = 'status connected';
            }

            handleResize() {
                this.updateDimensions();
                this.setupScales();
                this.setupSVG();
                this.invalidateCache();
                if (this.hasData) this.scheduleRender();
            }

            // Public methods
            pause() {
                document.getElementById('autoUpdate').checked = false;
            }

            resume() {
                document.getElementById('autoUpdate').checked = true;
            }

            destroy() {
                if (this.ws) this.ws.close();
                if (this.animationFrame) cancelAnimationFrame(this.animationFrame);
                this.svg.selectAll('*').remove();
                this.boundaryCache.clear();
                this.predictionCache.clear();
            }
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            try {
                window.neuralViz = new OptimizedNeuralViz();
                
                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    if (e.ctrlKey || e.metaKey) {
                        switch(e.key) {
                            case 'p':
                                e.preventDefault();
                                window.neuralViz.pause();
                                break;
                            case 'r':
                                e.preventDefault();
                                window.neuralViz.resume();
                                break;
                        }
                    }
                });
                
                // Cleanup
                window.addEventListener('beforeunload', () => {
                    if (window.neuralViz) window.neuralViz.destroy();
                });
                
            } catch (error) {
                console.error('Failed to initialize neural network visualization:', error);
                const statusEl = document.getElementById('connectionStatus');
                statusEl.innerHTML = '<div class="status-title">Initialization Error</div><div>Failed to start visualization</div>';
                statusEl.className = 'status error';
            }
        });
    </script>
</body>
</html>
